// 이번에는 정말 예측이 불가능한 에러를 처리하는 방법에 대해 알아보자.

// process 객체에 uncaughtException이벤트 리스너를 달아주었다.
// 처리하지 못한 에러가 발생했을 때 이벤트 리스너가 실행되고 프로세스가 유지된다.
// 이 부분이 없다면 위의 예제에서는 setTimeout이 실행되지 않는다.
// 실행 후 1초만에 setInterval에서 에러가 발생해 프로세스가 멈추기 때문이다.
// 하지만 uncaughtException 이벤트 리스너가 연결되어 있으므로 프로세스가 멈추지 않는다.
process.on('uncaughtException', (err) => {
	console.log('예기치 못한 에러', err);
});

setInterval(() => {
	throw new Error('서버를 고장내주마!');
}, 1000);

setTimeout(() => {
	console.log('실행됩니다');
}, 2000);

// try catch로 처리하지 못한 에러가 발생했지만 setInterval만 멈췄을 뿐 나머지 코드는 제대로 실행된다.
// 어떻게 보면 uncaughtException 이벤트 리스너로 모든 에러를 처리할 수 있을 것 같이 보인다.
// 실제로 콜백 함수에 에러 발생 시 복구 작업을 하는 코드를 넣어둔 사람을 본 적도 있다. 
// 하지만 노드 공식 문서에서는 uncaughtException이벤트를 최후의 수단으로 사용하라고 말하고 있다.
// 노드는 uncuaghtException 이벤트 발생 후 다음 동작이 제대로 동작하는지를 보증하지 않는다.
// 즉, 복수 작업 코드를 넣어두었더라도 그것이 동작하는지 확신할 수 없다.

// 따라서, 단순히 에러 내용을 기록하는 정도로 사용하고
// process.exit()로 프로세스를 종료하는 것이 좋다.

// 서버 운영은 에러와의 싸움이다.
// 모든 에러 상황에 대비하는 것이 최선이지만,
// 시간이나 비용, 인력 등의 제약으로 미처 대비하지 못한 에럴가 있을 수 있다.
// 따라서 에러 발생 시 철저히 기록(로깅)하는 습관을 들이고, 주기적으로 로그르 ㄹ확인하면서 보완해 나가야 한다. 